// DynASM directives.
|.arch x64
|.actionlist actions
|.define PROC, r10
|.define LFRAME, PROC+16
|.define SP, PROC+24
|.define IP, PROC+32
|.define FP, PROC+40
|.define CP, PROC+48
|.define SS, PROC+56
|.define BP, PROC+64
|.define MP, PROC+72
|.macro debug
|  mov ecx, opcode
|  mov rax, JIT_HANDLER_DBG
|  jmp &handler
|.endmacro
|.macro load_rp, target
|  mov r9, [FP]
|  mov r8, [SS]
|  imul r8, sizeof(oop)
|  mov target, [r9+r8]
|.endmacro
|.macro load_dp, target
|  mov r9, [FP]
|  mov r8, [SS]
|  imul r8, sizeof(oop)
|  mov target, [r9+r8+sizeof(oop)]
|.endmacro
#include "dynasm/dasm_proto.h"
#include "dynasm/dasm_x86.h"

#include "mmjit.hpp"
#include "utils.hpp"

#include <assert.h>
#include <stdio.h>
#include <sys/mman.h>

#define Dst &state

static
void initjit(dasm_State **state, const void *actionlist) {
  dasm_init(state, 1);
  dasm_setup(state, actionlist);
}

static
void *jitcode(dasm_State **state) {
  size_t size;
  int dasm_status = dasm_link(state, &size);
  assert(dasm_status == DASM_S_OK);

  // Allocate memory readable and writable so we can
  // write the encoded instructions there.
  char *mem = (char*) mmap(NULL, size + sizeof(size_t),
                           PROT_READ | PROT_WRITE,
                           MAP_ANON | MAP_PRIVATE, -1, 0);
  assert(mem != MAP_FAILED);

  // Store length at the beginning of the region, so we
  // can free it without additional context.
  *(size_t*)mem = size;
  void *ret = mem + sizeof(size_t);

  dasm_encode(state, ret);

  // Adjust the memory permissions so it is executable
  // but no longer writable.
  int success = mprotect(mem, size, PROT_EXEC | PROT_READ);
  assert(success == 0);

  // Write generated machine code to a temporary file.
  // View with:
  //  objdump -D -b binary -mi386 -Mx86-64 /tmp/jitcode
  // Or:
  //  ndisasm -b 64 /tmp/jitcode
  FILE *f = fopen("/tmp/jitcode", "wb");
  fwrite(ret, size, 1, f);
  fclose(f);

  return ret;
}

void free_jitcode(void *code) {
  void *mem = (char*)code - sizeof(size_t);
  int status = munmap(mem, *(size_t*)mem);
  assert(status == 0);
}


void* generate_jit_code(bytecode* _ip, number size, void* handler, boost::unordered_map<bytecode*, void*>& jmp_table) {
/*
 handler: a (label) address exit point so the code can jump out back to the VM

 This function returns an address for a block of compiled code.

 The code should be executed by jmp'ing into it (NOT calling it).
 whenever an opcode needs the VM to perform tasks, it will jump to *handler
 and put in eax the ID of the task needed (e.g. handling return, sends, etc).

 The "argument" to the code is a Process pointer that should be
 in r10 register prior to jumping into it.

 Finally, the compiled code makes strong assumptions about the layout of Process
 object, so any reordering of it's attributes will turn out badly.
*/

  dasm_State *state;
  initjit(&state, actions);
  dasm_growpc(&state, size); //dynamic labels


  bytecode* ip = _ip;
  for (int idx = 0; *ip; idx++, ip++) {
    bytecode instr = *ip;
    int opcode = decode_opcode(instr);
    int arg = decode_args(instr);

    //rax, r10, r11, [r9, r8, rcx, rdx, rsi, rdi]
    // 8 registers
    // 2 (maybe 3) per instruction
    // 6 registers (PROC, LFRAME, SP, IP, RP, DP)
    //ip++
    | =>idx:
    | mov rax, [IP] //ip
    | lea rcx, [rax+sizeof(bytecode)]
    | mov [IP], rcx

    switch(opcode) {
      case PUSH_LITERAL:
        //sp++, *sp = literal
        | mov rax, [SP] //rax = sp
        | lea rcx, [rax+sizeof(oop)] //rcx = sp+sizeof(oop)
        | mov [SP], rcx //sp = sp+1
        //sp = literal
        | mov r11, [LFRAME] //r11 = _literal_frame
        | mov rax, [r11+(arg*sizeof(oop))] //rax = *(_literal_frame+arg)
        | mov [rcx], rax //*sp=rax
        break;
      case POP_LOCAL:
        | mov rax, [SP] //rax = sp
        | mov rcx, [rax] //rcx = *sp
        | lea rax, [rax-sizeof(oop)] //rax = sp-sizeof(void*)
        | mov [SP], rax //sp = sp-1
        //sp = literal
        | mov r11, [FP] //fp
        | mov [r11+(arg*sizeof(oop))], rcx // *(fp + arg) = val
        break;
      case PUSH_LOCAL:
        //sp++, *sp = literal
        | mov rax, [SP] //rax = sp
        | lea rcx, [rax+sizeof(oop)] //rcx = sp+sizeof(oop)
        | mov [SP], rcx //sp = sp+1
        //sp = local
        | mov r11, [FP] //fp
        | mov rax, [r11+(arg*sizeof(oop))] // rax = *(fp + arg)
        | mov [rcx], rax //sp = rax
        break;
      case RETURN_TOP:
        | mov rax, JIT_HANDLER_RETURN_TOP
        | jmp &handler
        break;
      case RETURN_THIS:
        | mov rax, JIT_HANDLER_RETURN_THIS
        | jmp &handler
        break;
      case PUSH_MODULE:
        //sp++, *sp = md
        | mov rax, [SP] //rax = sp
        | lea rcx, [rax+sizeof(oop)] //rcx = sp+sizeof(oop)
        | mov [SP], rcx //sp = sp+1
        //sp = _mp
        | mov r11, [MP] //r11 = mp
        | mov [rcx], r11 //*sp = r11
        break;
      case PUSH_FIELD:
        //sp++, *sp = literal
        | mov rax, [SP] //rax = sp
        | lea rcx, [rax+sizeof(oop)] //rcx = sp+sizeof(oop)
        | mov [SP], rcx //sp = sp+1
        //        stack_push(*(dp() + arg + 2));
        | load_dp r11
        | mov r11, [r11+((arg+2)*sizeof(oop))]
        | mov [rcx], r11
        break;
      case PUSH_THIS:
        //sp++, *sp = literal
        | mov rax, [SP] //rax = sp
        | lea rcx, [rax+sizeof(oop)] //rcx = sp+sizeof(oop)
        | mov [SP], rcx //sp = sp+1
        | load_rp r11 //r11 = rp
        //sp = _rp
        | mov [rcx], r11 //*sp = r11
        break;
      case PUSH_FP:
        //sp++, *sp = literal
        | mov rax, [SP] //rax = sp
        | lea rcx, [rax+sizeof(oop)] //rcx = sp+sizeof(oop)
        | mov [SP], rcx //sp = sp+1
        //sp = _fp
        | mov r11, [FP] //r11 = fp
        | mov [rcx], r11 //*sp = r11
        break;
      case PUSH_CONTEXT:
        //sp++, *sp = literal
        | mov rax, [SP] //rax = sp
        | lea rcx, [rax+sizeof(oop)] //rcx = sp+sizeof(oop)
        | mov [SP], rcx //sp = sp+1
        //sp = _fp
        | mov r11, [CP] //r11 = cp
        | mov [rcx], r11 //*sp = r11
        break;
      case PUSH_BIN:
        //sp++, *sp = literal
        | mov rax, [SP] //rax = sp
        | lea rcx, [rax+sizeof(oop)] //rcx = sp+sizeof(oop)
        | mov [SP], rcx //sp = sp+1
        //sp = arg
        | mov [rcx], qword arg //*sp = arg
        break;
      case POP:
        | mov rax, [SP] //rax = sp
        | mov rcx, [rax] //rcx = *sp
        | lea rax, [rax-sizeof(oop)] //rax = sp-sizeof(void*)
        | mov [SP], rax //sp = sp-1
        break;
      case POP_FIELD:
        | mov rax, [SP] //rax = sp
        | mov rcx, [rax] //rcx = *sp
        | lea rax, [rax-sizeof(oop)] //rax = sp-sizeof(void*)
        | mov [SP], rax //sp = sp-1
        //*(dp() + arg + 2) = (word) val;
        | load_dp r11
        | lea r11, [r11+((arg+2)*sizeof(oop))]
        | mov [r11], rcx
        break;
      case SEND:
        | mov rcx, arg
        | mov rax, JIT_HANDLER_SEND
        | jmp &handler
        break;
      case SUPER_CTOR_SEND:
        | mov rcx, arg
        | mov rax, JIT_HANDLER_SUPER_CTOR_SEND
        | jmp &handler
        break;
      case CALL:
        | mov rcx, arg
        | mov rax, JIT_HANDLER_CALL
        | jmp &handler
        break;
      case JMP:
        // //ip += arg-1
        // | mov rax, [IP] //ip
        // | add rax, (arg*sizeof(bytecode))-sizeof(bytecode)
        // | mov [IP], rax
        // | jmp =>arg-1
        | mov rcx, arg
        | mov rax, JIT_HANDLER_JMP
        | jmp &handler
        break;
      case JMPB:
        //_ip -= (arg+1)
        // | mov rax, [IP] //ip
        // | sub rax, (arg*sizeof(bytecode))+sizeof(bytecode)
        // | mov [IP], rax
        // | jmp => -((arg*sizeof(bytecode))+sizeof(bytecode))
        | mov rcx, arg
        | mov rax, JIT_HANDLER_JMPB
        | jmp &handler
        break;
      case JZ:
        | mov rcx, arg
        | mov rax, JIT_HANDLER_JZ
        | jmp &handler
        break;
        // // val = stack_pop();
        // // DBG("JZ " << arg << " " << val << endl);
        // // if ((val == MM_FALSE) || (val == MM_NULL)) {
        // //   _ip += (arg -1); //_ip already suffered a ++ in dispatch
        // // }
        // | mov rax, [SP] //rax = sp
        // | mov rcx, [rax] //rcx = *sp
        // | lea rax, [rax-sizeof(oop)] //rax = sp-sizeof(void*)
        // | mov [SP], rax //sp = sp-1
        // | cmp rcx, 1
        // | jle >1
        // | mov rax, [IP] //ip
        // | add rax, =>idx+arg-1
        // | mov [IP], rax
        // | jmp =>idx+arg-1
        // | 1:
        // | nop
        // break;

      // case SUPER_SEND:
      //   | =>idx:
      //   | mov r11, arg
      //   | mov eax, JIT_HANDLER_CALL
      //   | jmp &handler
      default:
        printf("WRONG OPCODE %d\n", opcode);
    }
  }

  void *fptr = jitcode(&state);

  ip = _ip;
  for (int i = 0; *ip; i++, ip++) {
    int offset = dasm_getpclabel(&state, i);
    jmp_table[ip] = ((char*)fptr) + offset;
    // printf("ip %p = offset %d\n", ip, offset);
  }
  //dasm_free(state);
  return fptr;
}
