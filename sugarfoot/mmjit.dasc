// DynASM directives.
|.arch x64
|.actionlist actions
|.define PROC, r10
|.define LFRAME, PROC+16
|.define SP, PROC+24
|.define IP, PROC+32
|.define FP, PROC+40
|.define CP, PROC+48
|.define SS, PROC+56
|.define BP, PROC+64
|.define MP, PROC+72

#include "dynasm/dasm_proto.h"
#include "dynasm/dasm_x86.h"

#include "mmjit.hpp"
#include "utils.hpp"

#include <assert.h>
#include <stdio.h>
#include <sys/mman.h>

#define Dst &state

static
void initjit(dasm_State **state, const void *actionlist) {
  dasm_init(state, 1);
  dasm_setup(state, actionlist);
}

static
void *jitcode(dasm_State **state) {
  size_t size;
  int dasm_status = dasm_link(state, &size);
  assert(dasm_status == DASM_S_OK);

  // Allocate memory readable and writable so we can
  // write the encoded instructions there.
  char *mem = (char*) mmap(NULL, size + sizeof(size_t),
                           PROT_READ | PROT_WRITE,
                           MAP_ANON | MAP_PRIVATE, -1, 0);
  assert(mem != MAP_FAILED);

  // Store length at the beginning of the region, so we
  // can free it without additional context.
  *(size_t*)mem = size;
  void *ret = mem + sizeof(size_t);

  dasm_encode(state, ret);

  // Adjust the memory permissions so it is executable
  // but no longer writable.
  int success = mprotect(mem, size, PROT_EXEC | PROT_READ);
  assert(success == 0);

  // Write generated machine code to a temporary file.
  // View with:
  //  objdump -D -b binary -mi386 -Mx86-64 /tmp/jitcode
  // Or:
  //  ndisasm -b 64 /tmp/jitcode
  FILE *f = fopen("/tmp/jitcode", "wb");
  fwrite(ret, size, 1, f);
  fclose(f);

  return ret;
}

void free_jitcode(void *code) {
  void *mem = (char*)code - sizeof(size_t);
  int status = munmap(mem, *(size_t*)mem);
  assert(status == 0);
}


void* gnerate_jit_code(bytecode* ip, number size, void* handler) {
/*
 handler: a (label) address exit point so the code can jump out back to the VM

 This function returns an address for a block of compiled code.

 The code should be executed by jmp'ing into it (NOT calling it).
 whenever an opcode needs the VM to perform tasks, it will jump to *handler
 and put in eax the ID of the task needed (e.g. handling return, sends, etc).

 The "argument" to the code is a Process pointer that should be
 in r10 register prior to jumping into it.

 Finally, the compiled code makes strong assumptions about the layout of Process
 object, so any reordering of it's attributes will turn out badly.
*/

  dasm_State *state;
  initjit(&state, actions);
  dasm_growpc(&state, size); //dynamic labels


  for (int idx = 0; *ip; idx++, ip++) {
    bytecode instr = *ip;
    int opcode = decode_opcode(instr);
    int arg = decode_args(instr);

    //rax, r10, r11, [r9, r8, rcx, rdx, rsi, rdi]

    switch(opcode) {
      case PUSH_LITERAL:
        | =>idx:
        //sp++, *sp = literal
        | mov rax, [SP] //rax = sp
        | lea rcx, [rax+sizeof(oop)] //rcx = sp+sizeof(oop)
        | mov [SP], rcx //sp = sp+1
        //sp = literal
        | mov r11, [LFRAME] //r11 = _literal_frame
        | mov rax, [r11+arg] //rax = *(_literal_frame+arg)
        | mov [rcx], rax //*sp=rax
        //ip++
        | mov rax, [IP] //ip
        | lea rcx, [rax+sizeof(int)] ////int == bytecode
        | mov [IP], rcx
        break;
      case POP_LOCAL:
        | =>idx:
        | mov rax, [SP] //rax = sp
        | mov rcx, [rax] //rcx = *sp
        | lea rax, [rax-sizeof(oop)] //rax = sp-sizeof(void*)
        | mov [SP], rax //sp = sp-1
        //sp = literal
        | mov r11, [FP] //fp
        | mov [r11+arg], rcx // *(fp + arg) = val
        //ip++
        | mov rax, [IP] //ip
        | lea rcx, [rax+sizeof(int)] ////int == bytecode
        | mov [IP], rcx
        break;
      case PUSH_LOCAL:
        | =>idx:
        //sp++, *sp = literal
        | mov rax, [SP] //rax = sp
        | lea rcx, [rax+sizeof(oop)] //rcx = sp+sizeof(oop)
        | mov [SP], rcx //sp = sp+1
        //sp = local
        | mov r11, [FP] //fp
        | mov rax, [r11+arg] // rax = *(fp + arg)
        | mov [rcx], rax //sp = rax
        //ip++
        | mov rax, [IP] //ip
        | lea rcx, [rax+sizeof(int)] ////int == bytecode
        | mov [IP], rcx
        | mov eax, 1 //handle return_top
        | jmp &handler
        break;
      case RETURN_TOP:
        | =>idx:
        | mov eax, 1 //handle return_top
        | jmp &handler
        break;
      case RETURN_THIS:
        | =>idx:
        | mov eax, 2 //handle return
        | jmp &handler
        break;

      // //
      // case PUSH_THIS:
      //   | =>idx:
      //   //sp++, *sp = this
      //   | mov rax, [r10+0x8] //rax = sp
      //   | lea rcx, [rax+sizeof(void*)] //rcx = sp+sizeof(void*)
      //   | mov [r10+0x8], rcx //sp = sp+1
      //   //sp = rp
      //   | mov rsp, [r10+0x18] //fp
      //   | mov r11, [r10+0x28] //ss
      //   | mov rax, [rsp+r11] //rp
      //   | mov qword [rcx], rax //sp=rp
      //   //ip++
      //   | mov rax, [r10+0x10] //ip
      //   | lea rcx, [rax+sizeof(int)] ////int == bytecpde
      //   | mov [rax], rcx
      //   break;
      // case PUSH_MODULE:
      //   | =>idx:
      //   //sp++, *sp = this
      //   | mov rax, [r10+0x8] //sp
      //   | lea rcx, [rax+0x8] //sp+sizeof(void*)
      //   | mov [r10+0x8], rcx //sp = sp+1
      //   | mov rax, [r10+0x38] //mp
      //   | mov qword [rcx], rax //sp=mp
      //   //ip++
      //   | mov rax, [r10] //ip
      //   | lea rcx, [rax+sizeof(int)] ////int == bytecpde
      //   | mov [r10], rcx
      //   break;
      // case JMP:
      //   | =>idx:
      //   | jmp =>arg
      default:
        printf("WRONG OPCODE %d\n", ip);
    }
  }

  void *fptr = jitcode(&state);

  //dasm_free(state);
  return fptr;
}
